chip "test" {

  use Intent.Types as I;

  domain Objects {

    type Name extends I.String {
      :disallow() {
        return !this.length;
      }
    }

    type Object {
      name: Name;
    }

  }

  domain Alchemist {
    use Objects as O;

    type Ingredient extends O.Object {
      value: I.Number;
    }

    type Ingredients extends I.Collection<Ingredient> {
      value: I.Number;
    }

    type Formula extends O.Object {
      value: I.Number;
      ingredients: Ingredients;

      :disallow() {
        return !this.ingredients.count;
      }
    }

    type Environment {
      formulae: Formulae;

      preferred(ingredients: Ingredients, from: I.Collection<Formula>): Formula {

      }
    }

    type Brew {
      formula: Formula;
      environment: Environment;
    }

    type Formulae {
      all: I.Collection<Formula>;

      find(ingredients: Ingredients): I.Collection<Formula> {

      }
    }

    type Cauldron extends O.Object {
      environment: Environment;

      put(ingredients: Ingredients) {
        const formulas = this.environment.formulae.find(ingredients);

        return formulas
          ? this.environment.preferred(ingredients, formulas)
          : none;
      }

      brew(formula: Formula): Brew {
        return new Brew(formula, environment);
      }
    }

  }

  use Intent.Env as E;

  can (console: E.ConsoleEmitter) {
    const cauldron = Alchemist.Cauldron('Profound tier cauldron');

    emit console.log(`Cauldron: ${cauldron}`);

    const ingredient1 = Alchemist.Ingredient('Zhenshen', 1);
    const ingredient2 = Alchemist.Ingredient('Lotus');
    const ingredients = Alchemist.Ingredients(ingredient1, ingredient2);

    emit console.log(`Ingredients: ${ingredients}`);

    const formula = cauldron.put(ingredients);

    emit console.log(`Formula: ${formula}`);

    const brew = cauldron.brew(formula);

    emit console.log(`Brew: ${brew}`);
  }
}
