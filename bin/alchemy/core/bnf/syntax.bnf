
// module
module
  ::= use* domain

qualifier
  ::= identifier ('.' qualifier)?

use
  ::= 'use' qualifier (use_decomposition | use_alias) ';'

use_alias
  ::= 'as' identifier

use_decomposition
  ::= ':' '{' (use_decomposition_item ',')+ '}'

use_decomposition_item
  ::= qualifier use_decomposition?

// domain
domain
  ::= 'domain' identifier generic_definition? ('of' domain_reference)? '{' domain_body '}'

domain_body
  ::= constructor_properties? use? domain_clause* domain_method* constructor_method?

domain_clause
  ::= domain | enum

domain_method
  ::= identifier functor

enum
  ::= 'enum' identifier? ('of' domain_reference) '{' (enum_clause (',' enum_clause)*)? '}'

enum_clause
  ::= (enum_inheritor | identifier) '=' expression

enum_inheritor
  ::= ':' qualifier

constructor_properties
  ::= '{' (constructor_property (',' constructor_property)* ','?)? '}'

constructor_property
  ::= identifier (':' type_reference ('=' expression)) | ('=' expression)

constructor_method
  ::= 'do'? functor

// types
type_reference
  ::= domain_reference

// domain lookup
domain_reference
  ::= qualifier domain_reference_generic? ('[' ']')?

domain_reference_generic
  ::= '<' domain_reference (',' domain_reference)* '>'

// generic definitions
generic_definition
  ::= '<' identifier (',' identifier)* ','? '>'

// functor
functor
  ::= '(' functor_args? ')' (':' type_reference)? '=>' functor_body

functor_args
  ::= functor_arg (',' functor_arg)*

functor_body
  ::= block | expression

functor_arg
  ::= identifier ':' type_reference ('=' expression)?

// expressions
expression // !
  ::= boolean

parenthesis
  ::= '(' expression ')'

chain
  ::= '.' identifier

indexed
  ::= '[' expression ']'

call
  ::= '(' call_args? ')'

call_args
  ::= call_arg (',' call_arg)* ','?

call_arg
  ::= (identifier ':')? expression

boolean // !
  ::= comparison (('&&' | '||' | '^^') expression)*

comparison // !
  ::= additive (('>' | '<' | '>=' | '<=' | '!=' | '==') expression)*

additive // !
  ::= multiplicative (('+' | '-') expression)*

multiplicative // !
  ::= numerative (('*' | '/' | '%' | '**') expression)*

numerative // !
  ::= applicative (('&' | '|' | '^' | '>>' | '<<') expression)*

applicative // !
  ::= unary is*

unary // !
  ::= unary_operator* unary_mutator? assignable unary_mutator? call*

unary_operator // !
  ::= '+' | '-' | '~' | '!' | 'typeof'

unary_mutator // !
  ::= '--' | '++'

is // !
  ::= 'is' domain_reference

assignable
  ::= accessible (call? (chain | indexed))*

accessible
  ::= literal | object | array | match | callable | parenthesis | identifier

callable
  ::= functor

object
  ::= '{' (object_entry ',')* '}'

array
  ::= '[' (expression (',' expression)* ','?)? ']'

object_entry
  ::= identifier ':' expression

literal
  ::= string | number

// functor body
block
  ::= '{' decorated_block_item* '}'

decorator
  ::= '@' expression

decorated_block_item
  ::= decorator? block_item

block_item
  ::= if | loop | label | ((break | return | statement) ';')

label
  ::= identifier ':'

statement
  ::= ((declaration | assignable) assignment_token)? expression

assignment_token
  ::= '=' | '+=' | '-=' | '/=' | '*=' | '%=' | '**=' | '|=' | '&=' | '^='

declaration
  ::= 'let' identifier (':' type_reference)

match
  ::= 'match' (expression) '=>' '{' match_statement+ default_match_statement? '}'

match_statement
  ::= 'case' expression ('with' object)? ':' (block | decorated_block_item)

default_match_statement
  ::= 'else' (block | decorated_block_item)

loop
  ::= 'each' loop_iterator block

if
  ::= 'if' statement block ('else' block)?

break
  ::= ('break' | 'continue') (('@' identifier) | expression)?

return
  ::= 'return' expression

loop_iterator
  ::= declaration 'of' expression
