
// module
module
  ::= use* domain

qualifier
  ::= identifier ('.' identifier)*

use
  ::= 'use' qualifier (use_decomposition | use_alias) ';'

use_alias
  ::= 'as' identifier

use_decomposition
  ::= ':' '{' use_decomposition_item (',' use_decomposition_item)* ','? '}'

use_decomposition_item
  ::= qualifier use_decomposition?

// domain
domain
  ::= 'domain' identifier generic_definition? ('extends' type_reference)? '{' domain_body '}'

domain_body
  ::= constructor? use? domain_clause* can?

domain_clause
  ::= domain | enum

enum
  ::= 'enum' identifier ('extends' type_reference) '{' (enum_clause (',' enum_clause)*)? '}'

enum_clause
  ::= (enum_inheritor | identifier) '=' expression

enum_inheritor
  ::= ':' qualifier

constructor
  ::= '{' (constructor_property (',' constructor_property)* ','?)? '}'

constructor_property
  ::= identifier (':' type_reference ('=' expression)) | ('=' expression)

constructor_method
  ::= '('

// domain lookup
domain_reference
  ::= qualifier domain_reference_generic?

domain_reference_generic
  ::= '<' domain_reference (',' domain_reference)* '>'

// generic definitions

generic_definition
  ::= '<' identifier (',' identifier)* '>'

// methods
method
  ::= identifier function

function
  ::= '(' function_args? ')' (':' domain_reference)? '=>' function_body

function_args
  ::= arg (',' arg)*

arg
  ::= identifier ':' domain_reference ('=' expression)?

function_body
  ::= '{' (statement ';')* '}'

// statements
statement
  ::= assignment | expression

assignment
  ::= 'let' qualifier '=' expression

expression
  ::= comparision (chain | indexed | call)*

chain
  ::= '.' identifier

indexed
  ::= '[' expression ']'

call
  ::= '(' call_args? ')'

call_args
  ::= call_arg (',' call_arg)* ','?

call_arg
  ::= (identifier ':')? expression

comparision
  ::= boolean (('>' | '<' | '>=' | '<=' | '!=' | '==') expression)*

boolean
  ::= arithmetic1 (('&' | '|' | '^') expression)*

arithmetic1
  ::= arithmetic2 (('+' | '-') expression)*

arithmetic2
  ::= accessor (('*' | '/' | '%' | '**') expression)*

accessor
  ::= ('(' expression ')') | literal | identifier

literal
  ::= string | number

